#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  none)
#pragma config(Sensor, S2,     irSensor,       sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S3,     touchSensor,    sensorTouch)
#pragma config(Motor,  motorA,          motorSensor,   tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     motorLeft,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     motorRight,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     motorHang,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     motorLift,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     motorFlag,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     motorRoller,   tmotorTetrix, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"
#include "teleopFunctions.c"

int DEADZONE = 15;
int motorScale = 0.85;

//
void hangTask() { 					
	if(joy1Btn(2) == 1){			
		motor[motorHang] = 70;		
	}else{
		motor[motorHang] = 0;		
	}
}

void flagTask() { 					
if(joy1Btn(1) == 1){				
	motor[motorFlag] = 70; 			
	}else{
		motor[motorFlag] = 0;		


	}
}



// Allows left joystick to activate the lift.
void liftTask() {
if(abs(joy2Y1()) > DEADZONE) {
	motor[motorLift] = joy2Y2();
}	else{
	motor[motorLift] = 0;
}
}


// Allows right joystick to activate the roller.
void rollerTask() {
if(abs(joy2Y2()) > DEADZONE){
	motor[motorRoller] = joy2Y2();
}else{
	motor[motorRoller] = 0;
}
}


/* Drive Code
/		motorScale * (pow(joystick.joy1_y2, 3)) + (1 - motorScale) * (joystick.joy1_y2)
/		that line of code allows our joystick to make the motors curve along the equation
/
/		[y = ax^3 + (1-a)x]
/
/		Where a = scale
/					x = joystick input
/					y = adjusted joystick value
*/
void driveTask(){


	if(abs(joy1Y2()) > DEADZONE){
		motor[motorRight] = Ajoy1Y2();
	}else{
	motor[motorRight] = 0;
	}

	if(abs(joy1Y1) > DEADZONE){
		motor[motorLeft] = Ajoy1Y1();
	}else{
	motor[motorLeft] = 0;
	}
//

int joy1X1(){return joystick.joy1_x1;}       

int joy1X2(){return joystick.joy1_x2;}       

int joy1Y1(){return joystick.joy1_y1;}      
int Ajoy1Y1(){
	return motorScale * (pow(joy1Y1()), 3) + (1 - motorScale) * (joy1Y1());
}
}

int joy1Y2(){return joystick.joy1_y2;}  
int Ajoy1Y2(){ //adjusted joy1Y2
	return motorScale * (pow(joy1Y2()), 3) + (1 - motorScale) * (joy1Y2());
}

int joy2X1(){return joystick.joy2_x1;}

int joy2X2(){return joystick.joy2_x2;}

int joy2Y1(){return joystick.joy2_y1;}

int joy2Y2(){return joystick.joy2_y2;}



void initializeRobot()
{


  return;
}




task main()
{


  initializeRobot();

  waitForStart();

  while (true)
  {
  getJoystickSettings(joystick);
	driveTask();
	rollerTask();
	liftTask();
	hangTask();
	flagTask();
  }
}
